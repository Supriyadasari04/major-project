import { toast } from "@/hooks/use-toast";

const KEYS = {
  USER: "justly_user",
  GOALS: "justly_goals",
  HABITS: "justly_habits",
  TASKS: "justly_tasks",
  JOURNAL: "justly_journal",
  REFLECTIONS: "justly_reflections",
  CHAT_HISTORY: "justly_chat_history",
  ACHIEVEMENTS: "justly_achievements",
  SETTINGS: "justly_settings",
  ONBOARDING_COMPLETE: "justly_onboarding_complete",
  CHAT_SESSIONS: "justly_chat_sessions",
  ACTIVE_CHAT_SESSION_ID: "justly_active_chat_session_id",
};

export interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  createdAt: string;
}

export interface Goal {
  id: string;
  title: string;
  description: string;
  category: "health" | "career" | "wellness" | "relationships" | "personal";
  targetDate?: string;
  createdAt: string;
  progress: number;
}

export interface Habit {
  id: string;
  title: string;
  description?: string;
  category: "health" | "productivity" | "mindfulness" | "social" | "learning";
  frequency: "daily" | "weekly" | "custom";
  completedDates: string[];
  streak: number;
  createdAt: string;
  goalId?: string;
  icon?: string;
  color?: string;
}

export interface Task {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  date: string;
  habitId?: string;
  goalId?: string;
  priority: "low" | "medium" | "high";
  createdAt: string;
}

export interface JournalEntry {
  id: string;
  date: string;
  content: string;
  mood: "great" | "good" | "okay" | "low" | "difficult";
  tags: string[];
  autoGenerated: boolean;
  chatSummary?: string;
  reflectionSummary?: string;
  createdAt: string;
}

export interface Reflection {
  id: string;
  date: string;
  wins: string[];
  challenges: string[];
  gratitude: string[];
  lessonsLearned: string;
  mood: "great" | "good" | "okay" | "low" | "difficult";
  energyLevel: number;
  createdAt: string;
}

export interface ChatMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: string;
}

export interface ChatSession {
  id: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  pinned?: boolean;
}

export interface Achievement {
  id: string;
  title: string;
  description: string;
  icon: string;
  unlockedAt?: string;
  category: "streak" | "milestone" | "special";
}

export interface Settings {
  notifications: boolean;
  morningPrepTime: string;
  eveningReflectionTime: string;
  theme: "light" | "dark" | "system";
  privacy: {
    shareAnalytics: boolean;
    showStreak: boolean;
  };
  morningPrepCount?: number;

  // âœ… NEW (persisted)
  emotionTrackingEnabled?: boolean;
  emotionTrackingDisabledAt?: string | null;
  emotionTrackingLastReminderAt?: string | null;
}


export interface EmotionDetectionResult {
  emotionLabel: string;
  emotionScores?: Record<string, number>;
  crisisDetected?: boolean;
}


export interface MoodLog {
  id: string;
  userId: string;
  createdAt: string;
  source: string;
  inputText?: string;
  emotionLabel?: string;
  emotionScores?: Record<string, number>;
}


// helpers
const getToday = () => new Date().toISOString().split("T")[0];

const API_URL = "http://localhost:5000/api/auth";
const ONBOARDING_API = "http://localhost:5000/api/onboarding";
const CHAT_API = "http://localhost:5000/api/chat";
const EMOTION_API = "http://localhost:5000/api/emotion";


// ============================
// âœ… AUTH
// ============================
export const getUser = (): User | null => {
  const data = localStorage.getItem(KEYS.USER);
  return data ? JSON.parse(data) : null;
};

export const setUser = (user: User) => {
  localStorage.setItem(KEYS.USER, JSON.stringify(user));
};

export const createUser = async (
  name: string,
  email: string,
  password: string
): Promise<User> => {
  const res = await fetch(`${API_URL}/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, email, password }),
  });

  if (!res.ok) throw new Error("Signup failed");

  const user = await res.json();
  setUser(user);
  return user;
};

export const loginUser = async (
  email: string,
  password: string
): Promise<User | null> => {
  const res = await fetch(`${API_URL}/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });

  if (!res.ok) return null;

  const user = await res.json();
  setUser(user);
  return user;
};

export const logoutUser = () => {
  localStorage.removeItem(KEYS.USER);
  localStorage.removeItem(KEYS.ONBOARDING_COMPLETE);
  localStorage.removeItem(KEYS.ACTIVE_CHAT_SESSION_ID);
};

export const getTodayString = () => getToday();

// ============================
// âœ… GOALS
// ============================
export const getGoals = async (): Promise<Goal[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/goals/${user.id}`);
  const data = await res.json();

  return data.map((g: any) => ({
    ...g,
    createdAt: g.created_at,
  }));
};

export const addGoal = async (
  goal: Omit<Goal, "id" | "createdAt" | "progress">
): Promise<Goal> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/goals`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...goal, userId: user.id }),
  });

  if (!res.ok) throw new Error("Failed to add goal");

  const saved = await res.json();

  const finalGoal: Goal = {
    ...saved,
    createdAt: saved.created_at,
  };

  await checkAndUnlockGoalsAchievement();

  return finalGoal;
};

export const updateGoal = async (
  goalId: string,
  updates: Partial<Pick<Goal, "title" | "description" | "category" | "progress">>
): Promise<Goal> => {
  const res = await fetch(`${ONBOARDING_API}/goals/${goalId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(updates),
  });

  if (!res.ok) throw new Error("Failed to update goal");

  const updated = await res.json();

  return {
    ...updated,
    createdAt: updated.created_at,
  };
};

export const deleteGoal = async (goalId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/goals/${goalId}`, {
    method: "DELETE",
  });

  if (!res.ok) throw new Error("Failed to delete goal");
};

// ============================
// âœ… HABITS
// ============================
export const getHabits = async (): Promise<Habit[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/habits/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch habits");

  const data = await res.json();

  return data.map((h: any) => {
    const rawDates = h.completed_dates ?? [];
    const completedDates = Array.isArray(rawDates)
      ? rawDates.map((d: any) => String(d).slice(0, 10))
      : [];

    return {
      ...h,
      createdAt: h.created_at,
      completedDates,
      streak: h.streak ?? 0,
    };
  });
};

export const addHabit = async (
  habit: Omit<Habit, "id" | "createdAt" | "completedDates" | "streak">
): Promise<Habit> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/habits`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...habit, userId: user.id }),
  });

  if (!res.ok) throw new Error("Failed to add habit");

  const saved = await res.json();

  const rawDates = saved.completed_dates ?? [];
  const completedDates = Array.isArray(rawDates)
    ? rawDates.map((d: any) => String(d).slice(0, 10))
    : [];

  return {
    ...saved,
    createdAt: saved.created_at,
    completedDates,
    streak: saved.streak ?? 0,
  };
};

export const completeHabit = async (habitId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/habits/${habitId}/complete`, {
    method: "POST",
  });

  if (!res.ok) throw new Error("Failed to complete habit");

  const updated = await res.json();

  // âœ… achievements toast
  try {
    await unlockIfNotAlready("first_habit");
  } catch (err) {
    console.error("Achievement unlock failed:", err);
  }

  try {
    const streak = updated?.streak ?? 0;
    if (streak >= 7) await unlockIfNotAlready("streak_7");
    if (streak >= 30) await unlockIfNotAlready("streak_30");
  } catch (err) {
    console.error("Streak achievement unlock failed:", err);
  }
};

export const uncompleteHabit = async (_habitId: string): Promise<void> => {
  // You said: once completed, user cannot uncomplete âœ…
  return;
};

export const deleteHabit = async (habitId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/habits/${habitId}`, {
    method: "DELETE",
  });

  if (!res.ok) throw new Error("Failed to delete habit");
};

// ============================
// âœ… TASKS
// ============================
export const getTasks = async (date?: string): Promise<Task[]> => {
  const user = getUser();
  if (!user) return [];

  const d = date ?? getToday();

  const res = await fetch(`${ONBOARDING_API}/tasks/${user.id}/${d}`);
  if (!res.ok) throw new Error("Failed to fetch tasks");

  const data = await res.json();

  return data.map((t: any) => ({
    ...t,
    createdAt: t.created_at,
  }));
};

export const addTask = async (
  task: Omit<Task, "id" | "createdAt">
): Promise<Task> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/tasks`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...task, userId: user.id }),
  });

  if (!res.ok) throw new Error("Failed to add task");

  const saved = await res.json();

  return {
    ...saved,
    createdAt: saved.created_at,
  };
};

export const toggleTask = async (taskId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/tasks/${taskId}/toggle`, {
    method: "PATCH",
  });

  if (!res.ok) throw new Error("Failed to toggle task");
};

export const deleteTask = async (taskId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/tasks/${taskId}`, {
    method: "DELETE",
  });

  if (!res.ok) throw new Error("Failed to delete task");
};

// ============================
// âœ… JOURNAL
// ============================
export const getJournalEntries = async (): Promise<JournalEntry[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/journal/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch journal entries");

  const data = await res.json();

  return data.map((j: any) => ({
    id: j.id,
    date: j.date,
    content: j.content,
    mood: j.mood,
    tags: j.tags ?? [],
    autoGenerated: j.auto_generated ?? false,
    chatSummary: j.chat_summary ?? undefined,
    reflectionSummary: j.reflection_summary ?? undefined,
    createdAt: j.created_at,
  }));
};

export const addJournalEntry = async (
  entry: Omit<JournalEntry, "id" | "createdAt">
): Promise<JournalEntry> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/journal`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...entry, userId: user.id }),
  });

  if (!res.ok) throw new Error("Failed to add journal entry");

  const saved = await res.json();

  const finalEntry: JournalEntry = {
    id: saved.id,
    date: saved.date,
    content: saved.content,
    mood: saved.mood,
    tags: saved.tags ?? [],
    autoGenerated: saved.auto_generated ?? false,
    chatSummary: saved.chat_summary ?? undefined,
    reflectionSummary: saved.reflection_summary ?? undefined,
    createdAt: saved.created_at,
  };

  await checkAndUnlockJournalAchievement();

  return finalEntry;
};

export const updateJournalEntry = async (
  journalId: string,
  updates: { content?: string }
): Promise<JournalEntry> => {
  const res = await fetch(`${ONBOARDING_API}/journal/${journalId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(updates),
  });

  if (!res.ok) throw new Error("Failed to update journal entry");

  const saved = await res.json();

  return {
    id: saved.id,
    date: saved.date,
    content: saved.content,
    mood: saved.mood,
    tags: saved.tags ?? [],
    autoGenerated: saved.auto_generated ?? false,
    chatSummary: saved.chat_summary ?? undefined,
    reflectionSummary: saved.reflection_summary ?? undefined,
    createdAt: saved.created_at,
  };
};

export const deleteJournalEntry = async (journalId: string): Promise<void> => {
  const res = await fetch(`${ONBOARDING_API}/journal/${journalId}`, {
    method: "DELETE",
  });

  if (!res.ok) throw new Error("Failed to delete journal entry");
};

// ============================
// âœ… REFLECTIONS
// ============================
export const getReflections = async (): Promise<Reflection[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/reflections/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch reflections");

  const data = await res.json();

  return data.map((r: any) => ({
    id: r.id,
    date: r.date,
    wins: r.wins ?? [],
    challenges: r.challenges ?? [],
    gratitude: r.gratitude ?? [],
    lessonsLearned: r.lessons_learned ?? "",
    mood: r.mood,
    energyLevel: r.energy_level ?? 5,
    createdAt: r.created_at,
  }));
};

export const addReflection = async (
  reflection: Omit<Reflection, "id" | "createdAt">
): Promise<Reflection> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/reflections`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ ...reflection, userId: user.id }),
  });

  if (!res.ok) throw new Error("Failed to add reflection");

  const saved = await res.json();

  try {
    await unlockIfNotAlready("first_reflection");
  } catch (err) {
    console.error("Failed to unlock first_reflection achievement:", err);
  }

  return {
    id: saved.id,
    date: saved.date,
    wins: saved.wins ?? [],
    challenges: saved.challenges ?? [],
    gratitude: saved.gratitude ?? [],
    lessonsLearned: saved.lessons_learned ?? "",
    mood: saved.mood,
    energyLevel: saved.energy_level ?? 5,
    createdAt: saved.created_at,
  };
};

// ============================
// âœ… CHAT
// ============================
export const getActiveChatSessionId = (): string | null => {
  return localStorage.getItem(KEYS.ACTIVE_CHAT_SESSION_ID);
};

export const setActiveChatSessionId = (sessionId: string | null) => {
  if (!sessionId) {
    localStorage.removeItem(KEYS.ACTIVE_CHAT_SESSION_ID);
    return;
  }
  localStorage.setItem(KEYS.ACTIVE_CHAT_SESSION_ID, sessionId);
};

const generateChatTitleFromText = (text: string) => {
  const cleaned = text.replace(/\s+/g, " ").trim().replace(/[^\w\s]/g, "");
  if (!cleaned) return "New Chat";

  const words = cleaned.split(" ").slice(0, 6).join(" ");
  return words.length > 35 ? words.slice(0, 35) + "â€¦" : words;
};

export const getChatSessions = async (): Promise<ChatSession[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${CHAT_API}/sessions/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch chat sessions");

  const data = await res.json();

  return data.map((s: any) => ({
    id: s.id,
    title: s.title,
    createdAt: s.created_at,
    updatedAt: s.updated_at,
    pinned: s.pinned ?? false,
  }));
};

export const createChatSession = async (): Promise<ChatSession> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${CHAT_API}/sessions`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      userId: user.id,
      title: "New Chat",
    }),
  });

  if (!res.ok) throw new Error("Failed to create chat session");

  const s = await res.json();

  const session: ChatSession = {
    id: s.id,
    title: s.title,
    createdAt: s.created_at,
    updatedAt: s.updated_at,
    pinned: s.pinned ?? false,
  };

  setActiveChatSessionId(session.id);

  return session;
};

export const renameChatSession = async (
  sessionId: string,
  newTitle: string
): Promise<void> => {
  const title = newTitle.trim() || "New Chat";

  const res = await fetch(`${CHAT_API}/sessions/${sessionId}/rename`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ title }),
  });

  if (!res.ok) throw new Error("Failed to rename chat session");
};

export const togglePinChatSession = async (sessionId: string): Promise<void> => {
  const res = await fetch(`${CHAT_API}/sessions/${sessionId}/pin`, {
    method: "PATCH",
  });

  if (!res.ok) throw new Error("Failed to pin/unpin chat session");
};

export const deleteChatSession = async (sessionId: string): Promise<void> => {
  const res = await fetch(`${CHAT_API}/sessions/${sessionId}`, {
    method: "DELETE",
  });

  if (!res.ok) throw new Error("Failed to delete chat session");

  const active = getActiveChatSessionId();
  if (active === sessionId) {
    setActiveChatSessionId(null);
  }
};

export const getChatMessagesBySession = async (
  sessionId: string
): Promise<ChatMessage[]> => {
  const res = await fetch(`${CHAT_API}/messages/${sessionId}`);
  if (!res.ok) throw new Error("Failed to fetch chat messages");

  const data = await res.json();

  return data.map((m: any) => ({
    id: m.id,
    role: m.role,
    content: m.content,
    timestamp: m.created_at,
  }));
};

export const addMessageToSession = async (
  sessionId: string,
  message: Omit<ChatMessage, "id" | "timestamp">
): Promise<ChatMessage> => {
  const res = await fetch(`${CHAT_API}/messages/${sessionId}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      role: message.role,
      content: message.content,
    }),
  });

  if (!res.ok) throw new Error("Failed to add chat message");

  const saved = await res.json();

  const savedMessage: ChatMessage = {
    id: saved.id,
    role: saved.role,
    content: saved.content,
    timestamp: saved.created_at,
  };

  // âœ… auto-title
  if (message.role === "user") {
    try {
      const sessions = await getChatSessions();
      const session = sessions.find((s) => s.id === sessionId);

      if (session && session.title === "New Chat") {
        const newTitle = generateChatTitleFromText(message.content);
        await renameChatSession(sessionId, newTitle);
      }
    } catch {
      // ignore
    }
  }

  return savedMessage;
};

export const getChatHistory = async (): Promise<ChatMessage[]> => {
  const sessionId = getActiveChatSessionId();
  if (!sessionId) return [];
  return await getChatMessagesBySession(sessionId);
};

// ============================
// âœ… EMOTION DETECTION âœ… NEW
// ============================


// âœ… This will be called automatically from Coach when user sends message

export const analyzeEmotion = async (text: string, source: string = "coach"): Promise<MoodLog> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${EMOTION_API}/analyze`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId: user.id, text, source }),
  });

  if (!res.ok) throw new Error("Failed to analyze emotion");
  const saved = await res.json();

  return {
    id: saved.id,
    userId: saved.user_id,
    createdAt: saved.created_at,
    source: saved.source,
    inputText: saved.input_text ?? undefined,
    emotionLabel: saved.emotion_label ?? undefined,
    emotionScores: saved.emotion_scores ?? undefined,
  };
};

export const getMoodLogsByMonth = async (
  year: number,
  month: number
): Promise<MoodLog[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/mood/${user.id}/month?year=${year}&month=${month}`);
  if (!res.ok) throw new Error("Failed to fetch mood logs");

  const data = await res.json();

  return data.map((m: any) => ({
    id: m.id,
    userId: m.user_id,
    createdAt: m.created_at,
    source: m.source,
    inputText: m.input_text ?? undefined,
    emotionLabel: m.emotion_label ?? undefined,
    emotionScores: m.emotion_scores ?? undefined,
  }));
};

// ============================
// âœ… ACHIEVEMENTS (toast celebrations)
// ============================
export const getAchievements = async (): Promise<Achievement[]> => {
  const user = getUser();
  if (!user) return [];

  const res = await fetch(`${ONBOARDING_API}/achievements/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch achievements");

  const data = await res.json();

  return data.map((a: any) => ({
    id: a.achievement_id ?? a.id,
    title: a.title,
    description: a.description,
    icon: a.icon,
    category: a.category,
    unlockedAt: a.unlocked_at ?? undefined,
  }));
};

export const unlockAchievement = async (id: string): Promise<Achievement | null> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/achievements/${user.id}/${id}/unlock`, {
    method: "PATCH",
  });

  if (!res.ok) throw new Error("Failed to unlock achievement");

  const a = await res.json();

  return {
    id: a.achievement_id ?? a.id,
    title: a.title,
    description: a.description,
    icon: a.icon,
    category: a.category,
    unlockedAt: a.unlocked_at ?? undefined,
  };
};

const ACHIEVEMENT_CELEBRATIONS: Record<string, { title: string; description: string }> = {
  first_habit: {
    title: "ðŸŽ‰ Achievement Unlocked: First Step!",
    description: "You completed your first habit â€” keep the momentum going ðŸŒ±",
  },
  streak_7: {
    title: "ðŸ”¥ Achievement Unlocked: Week Warrior!",
    description: "7-day streak! Your consistency is building real change ðŸ’ª",
  },
  streak_30: {
    title: "â­ Achievement Unlocked: Monthly Master!",
    description: "30 days strong â€” thatâ€™s discipline at its best ðŸ†",
  },
  goals_3: {
    title: "ðŸŽ¯ Achievement Unlocked: Goal Getter!",
    description: "3 goals set â€” now you're officially serious about growth ðŸš€",
  },
  journal_10: {
    title: "ðŸ“– Achievement Unlocked: Story Teller!",
    description: "10 journal entries â€” self-awareness level up ðŸ§ âœ¨",
  },
  first_reflection: {
    title: "ðŸ§˜ Achievement Unlocked: Mindful Moment!",
    description: "Your first reflection is saved â€” keep checking in with yourself ðŸ’œ",
  },
  morning_prep_7: {
    title: "ðŸŒ… Achievement Unlocked: Early Bird!",
    description: "7 morning preps! Youâ€™re designing your day like a pro âœ…",
  },
  chat_coach_10: {
    title: "ðŸ’¬ Achievement Unlocked: Open Mind!",
    description: "10 coaching sessions â€” youâ€™re investing in yourself ðŸ’¯",
  },
};

const unlockIfNotAlready = async (achievementId: string) => {
  const user = getUser();
  if (!user) return;

  try {
    const before = await getAchievements();
    const wasUnlocked = before.find((a) => a.id === achievementId)?.unlockedAt;

    const unlocked = await unlockAchievement(achievementId);

    const afterUnlocked = unlocked?.unlockedAt;
    if (!wasUnlocked && afterUnlocked) {
      const msg = ACHIEVEMENT_CELEBRATIONS[achievementId];

      toast({
        title: msg?.title ?? "ðŸŽ‰ Achievement unlocked!",
        description: msg?.description ?? "You earned a new badge!",
      });
    }
  } catch (err) {
    console.error("unlockIfNotAlready error:", err);
  }
};

const checkAndUnlockGoalsAchievement = async () => {
  const user = getUser();
  if (!user) return;

  try {
    const goals = await getGoals();
    if (goals.length >= 3) {
      await unlockIfNotAlready("goals_3");
    }
  } catch (err) {
    console.error("checkAndUnlockGoalsAchievement error:", err);
  }
};

const checkAndUnlockJournalAchievement = async () => {
  const user = getUser();
  if (!user) return;

  try {
    const journals = await getJournalEntries();
    if (journals.length >= 10) {
      await unlockIfNotAlready("journal_10");
    }
  } catch (err) {
    console.error("checkAndUnlockJournalAchievement error:", err);
  }
};

// ============================
// âœ… SETTINGS
// ============================
export const getSettings = async (): Promise<Settings> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/settings/${user.id}`);
  if (!res.ok) throw new Error("Failed to fetch settings");

  const data = await res.json();

  // âœ… Ensure frontend always has a valid object
  return {
    notifications: data.notifications ?? true,
    morningPrepTime: data.morningPrepTime ?? "07:00",
    eveningReflectionTime: data.eveningReflectionTime ?? "21:00",
    theme: data.theme ?? "light",
    privacy: {
      shareAnalytics: data.privacy?.shareAnalytics ?? false,
      showStreak: data.privacy?.showStreak ?? true,
    },
    morningPrepCount: data.morningPrepCount ?? 0,

    // âœ… NEW
    emotionTrackingEnabled: data.emotionTrackingEnabled ?? true,
    emotionTrackingDisabledAt: data.emotionTrackingDisabledAt ?? null,
    emotionTrackingLastReminderAt: data.emotionTrackingLastReminderAt ?? null,
  };
};


export const saveSettings = async (settings: Settings): Promise<void> => {
  const user = getUser();
  if (!user) throw new Error("Not authenticated");

  const res = await fetch(`${ONBOARDING_API}/settings/${user.id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(settings),
  });

  if (!res.ok) throw new Error("Failed to update settings");
};

export const recordMorningPrepAndUnlockAchievement = async (): Promise<void> => {
  const settings = await getSettings();

  const current = settings.morningPrepCount ?? 0;
  const nextCount = current + 1;

  await saveSettings({
    ...settings,
    morningPrepCount: nextCount,
  });

  if (nextCount >= 7) {
    await unlockIfNotAlready("morning_prep_7");
  }
};

export const setOnboardingComplete = async () => {
  const user = getUser();
  if (!user) return;

  await fetch(`${ONBOARDING_API}/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId: user.id }),
  });

  localStorage.setItem(KEYS.ONBOARDING_COMPLETE, "true");
};

export const isOnboardingComplete = async (): Promise<boolean> => {
  const user = getUser();
  if (!user) return false;

  const res = await fetch(`${ONBOARDING_API}/status/${user.id}`);
  const data = await res.json();
  return data.completed;
};